<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pydft_qmmm.plugins.pme.pme_utils &#8212; PyDFT-QMMM 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />

  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />





  </head><body>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">


          <div class="body" role="main">

  <h1>Source code for pydft_qmmm.plugins.pme.pme_utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Core functionality for the QM/MM/PME algorithm.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">import</span> <span class="nn">numba</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>

<span class="kn">from</span> <span class="nn">pydft_qmmm.common</span> <span class="kn">import</span> <span class="n">Subsystem</span>
<span class="kn">from</span> <span class="nn">pydft_qmmm.common</span> <span class="kn">import</span> <span class="n">BOHR_PER_ANGSTROM</span>
<span class="kn">from</span> <span class="nn">pydft_qmmm.common</span> <span class="kn">import</span> <span class="n">KJMOL_PER_EH</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">NDArray</span>
    <span class="kn">from</span> <span class="nn">pydft_qmmm</span> <span class="kn">import</span> <span class="n">System</span>


<span class="n">BOHR_PER_NM</span> <span class="o">=</span> <span class="mf">18.89726</span>  <span class="c1"># a0 / nm</span>


<div class="viewcode-block" id="pme_components">
<a class="viewcode-back" href="../../../../pydft_qmmm.plugins.pme.html#pydft_qmmm.plugins.pme.pme_utils.pme_components">[docs]</a>
<span class="k">def</span> <span class="nf">pme_components</span><span class="p">(</span>
        <span class="n">system</span><span class="p">:</span> <span class="n">System</span><span class="p">,</span>
        <span class="n">quadrature</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">pme_potential</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">pme_gridnumber</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">pme_alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute relevant components of the PME potential.</span>

<span class="sd">    Args:</span>
<span class="sd">        system: The system from which the PME potential is derived.</span>
<span class="sd">        quadrature: The quadrature grid positions (:math:`\mathrm{a.u.}`)</span>
<span class="sd">            of the DFT calculation.</span>
<span class="sd">        pme_potential: The PME potential at gridpoints defined in the MM</span>
<span class="sd">            interface.</span>
<span class="sd">        pme_gridnumber: The number of grid points to include along each</span>
<span class="sd">            lattice edge in PME summation.</span>
<span class="sd">        pme_alpha: The Gaussian width parameter in Ewald summation</span>
<span class="sd">            (:math:`\mathrm{nm^{-1}}`).</span>

<span class="sd">    Returns:</span>
<span class="sd">        The reciprocal-space correction energy, the PME potential at</span>
<span class="sd">        quadrature grid coordinates, the PME potential at nuclear</span>
<span class="sd">        coordinates, and the derivative of the PME potential at</span>
<span class="sd">        nuclear coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create necessary objects.</span>
    <span class="n">qm_atoms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">subsystem_map</span><span class="p">[</span><span class="n">Subsystem</span><span class="o">.</span><span class="n">I</span><span class="p">])</span>
    <span class="n">nuclei</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">system</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">qm_atoms</span><span class="p">,</span> <span class="p">:]</span>
        <span class="o">*</span> <span class="n">BOHR_PER_ANGSTROM</span>
    <span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">pme_gridnumber</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="n">inverse_box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span>
        <span class="n">system</span><span class="o">.</span><span class="n">box</span> <span class="o">*</span> <span class="n">BOHR_PER_ANGSTROM</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ae_atoms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">subsystem_map</span><span class="p">[</span><span class="n">Subsystem</span><span class="o">.</span><span class="n">II</span><span class="p">])</span>
    <span class="n">atoms</span> <span class="o">=</span> <span class="n">qm_atoms</span> <span class="o">+</span> <span class="n">ae_atoms</span>  <span class="c1"># + qm_drudes</span>
    <span class="c1"># Gather relevant State data.</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">positions</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">*</span> <span class="n">BOHR_PER_ANGSTROM</span>
    <span class="n">charges</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">charges</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
    <span class="c1"># Determine and apply exclusions.</span>
    <span class="n">pme_xyz</span><span class="p">,</span> <span class="n">pme_exclusions</span> <span class="o">=</span> <span class="n">_compute_pme_exclusions</span><span class="p">(</span>
        <span class="n">system</span><span class="o">.</span><span class="n">box</span><span class="p">,</span>
        <span class="n">inverse_box</span><span class="p">,</span>
        <span class="n">quadrature</span><span class="p">,</span>
        <span class="n">pme_gridnumber</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">_apply_pme_exclusions</span><span class="p">(</span>
        <span class="n">system</span><span class="o">.</span><span class="n">box</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">,</span>
        <span class="n">positions</span><span class="p">,</span>
        <span class="n">charges</span><span class="p">,</span>
        <span class="n">pme_potential</span><span class="p">,</span>
        <span class="n">pme_xyz</span><span class="p">,</span>
        <span class="n">pme_exclusions</span><span class="p">,</span>
        <span class="n">pme_gridnumber</span><span class="p">,</span>
        <span class="n">pme_alpha</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Prepare arrays for interpolation.</span>
    <span class="n">pme_potential</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">pme_potential</span><span class="p">,</span>
        <span class="p">(</span><span class="n">pme_gridnumber</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">pme_potential</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">pme_potential</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">)</span>
    <span class="c1"># Perform interpolations.</span>
    <span class="n">pme_results</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_interp_pme_potential</span><span class="p">(</span>
            <span class="n">inverse_box</span><span class="p">,</span>
            <span class="n">grid</span><span class="p">,</span>
            <span class="n">pme_potential</span><span class="p">,</span>
            <span class="n">pme_gridnumber</span><span class="p">,</span>
            <span class="n">quadrature</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">_interp_pme_potential</span><span class="p">(</span>
            <span class="n">inverse_box</span><span class="p">,</span>
            <span class="n">grid</span><span class="p">,</span>
            <span class="n">pme_potential</span><span class="p">,</span>
            <span class="n">pme_gridnumber</span><span class="p">,</span>
            <span class="n">nuclei</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>
    <span class="n">pme_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">_interp_pme_gradient</span><span class="p">(</span>
            <span class="n">inverse_box</span><span class="p">,</span>
            <span class="n">grid</span><span class="p">,</span>
            <span class="n">pme_potential</span><span class="p">,</span>
            <span class="n">pme_gridnumber</span><span class="p">,</span>
            <span class="n">nuclei</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="c1"># Calculate reciprocal-space correction energy.</span>
    <span class="n">pme_results</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="nb">sum</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="o">-</span><span class="n">v</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">KJMOL_PER_EH</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">pme_results</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">system</span><span class="o">.</span><span class="n">charges</span><span class="p">[</span><span class="n">qm_atoms</span><span class="p">])</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pme_results</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_compute_pme_exclusions</span><span class="p">(</span>
        <span class="n">box</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">inverse_box</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">quadrature</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">pme_gridnumber</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine which PME grid points will participate in interpolation.</span>

<span class="sd">    Args:</span>
<span class="sd">        box: The lattice vectors (:math:`\mathrm{\mathring{A}}`) of the box</span>
<span class="sd">            containing the system.</span>
<span class="sd">        inverse_box: The inverse lattice vectors</span>
<span class="sd">            (:math:`\mathrm{a.u.^{-1}}`) of the box containing the</span>
<span class="sd">            system.</span>
<span class="sd">        quadrature: The quadrature grid positions (:math:`\mathrm{a.u.}`)</span>
<span class="sd">            of the DFT calculation.</span>
<span class="sd">        pme_gridnumber: The number of grid points to include along each</span>
<span class="sd">            lattice edge in PME summation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The x, y, and z, coordinates of PME gridpoints, and</span>
<span class="sd">        the array indices of PME grid points which will participate</span>
<span class="sd">        in interpolation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create real-space coordinates of the PME grid in Bohr.</span>
    <span class="n">norms</span> <span class="o">=</span> <span class="n">BOHR_PER_ANGSTROM</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">norms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pme_gridnumber</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">norms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pme_gridnumber</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">norms</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pme_gridnumber</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">pme_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Project quadrature grid to reciprocal space.</span>
    <span class="n">points_project</span> <span class="o">=</span> <span class="n">project_to_grid</span><span class="p">(</span><span class="n">inverse_box</span><span class="p">,</span> <span class="n">pme_gridnumber</span><span class="p">,</span> <span class="n">quadrature</span><span class="p">)</span>
    <span class="n">x_i</span> <span class="o">=</span> <span class="n">points_project</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x_i</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]))</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
    <span class="n">x_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x_f</span><span class="p">[</span><span class="n">x_f</span> <span class="o">==</span> <span class="n">pme_gridnumber</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pme_exclusions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x_f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pme_xyz</span><span class="p">,</span> <span class="n">pme_exclusions</span>


<span class="k">def</span> <span class="nf">_apply_pme_exclusions</span><span class="p">(</span>
        <span class="n">box</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">positions</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">charges</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">pme_potential</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">pme_xyz</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">pme_exclusions</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span>
        <span class="n">pme_gridnumber</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">pme_alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply exlcusions to relevant PME potential grid points.</span>

<span class="sd">    Args:</span>
<span class="sd">        box: The lattice vectors (:math:`\mathrm{\mathring{A}}`) of the box</span>
<span class="sd">            containing the system.</span>
<span class="sd">        atoms: The list of atom indices corresponding to subsystems</span>
<span class="sd">            I &amp; II in the principal cell, whose potential will need to</span>
<span class="sd">            be removed from the PME grid.</span>
<span class="sd">        positions: The positions (:math:`\mathrm{a.u.}`) of the atoms</span>
<span class="sd">            within subsystems I &amp; II in the principal cell.</span>
<span class="sd">        charges: The partial charges (:math:`e`) of the atoms within</span>
<span class="sd">            subsystems I &amp; II in the principal cell.</span>
<span class="sd">        pme_potential: The PME potential at gridpoints defined in the MM</span>
<span class="sd">            interface.</span>
<span class="sd">        pme_xyz: The x, y, and z, coordinates (:math:`\mathrm{a.u.}`) of</span>
<span class="sd">            PME grid points.</span>
<span class="sd">        pme_exclusions: The array indices of PME grid points which will</span>
<span class="sd">            participate in interpolation.</span>
<span class="sd">        pme_gridnumber: The number of grid points to include along each</span>
<span class="sd">            lattice edge in PME summation.</span>
<span class="sd">        pme_alpha: The Gaussian width parameter in Ewald summation</span>
<span class="sd">            (:math:`\mathrm{nm^{-1}}`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">pme_exclusions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">pme_gridnumber</span><span class="o">**</span><span class="mi">2</span>
        <span class="o">+</span> <span class="n">pme_exclusions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">pme_gridnumber</span>
        <span class="o">+</span> <span class="n">pme_exclusions</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="c1"># Perform exclusion calculation</span>
    <span class="n">exclusions</span> <span class="o">=</span> <span class="n">pme_xyz</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">pme_alpha</span> <span class="o">/</span> <span class="n">BOHR_PER_NM</span>
    <span class="n">pme_potential</span> <span class="o">=</span> <span class="n">_compute_reciprocal_exclusions</span><span class="p">(</span>
        <span class="n">pme_potential</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">positions</span><span class="p">,</span>
        <span class="n">charges</span><span class="p">,</span>
        <span class="n">exclusions</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">box</span> <span class="o">*</span> <span class="n">BOHR_PER_ANGSTROM</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_interp_pme_potential</span><span class="p">(</span>
        <span class="n">inverse_box</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">grid</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]],</span>
        <span class="n">pme_potential</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">pme_gridnumber</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates the PME potential interpolated at the points.</span>

<span class="sd">    Args:</span>
<span class="sd">        inverse_box: The inverse lattice vectors</span>
<span class="sd">            (:math:`\mathrm{a.u.^{-1}}`) of the box containing the</span>
<span class="sd">            system.</span>
<span class="sd">        grid: Arrays of possible grid indices for interpolation.</span>
<span class="sd">        pme_potential: The PME potential at gridpoints defined in the MM</span>
<span class="sd">            interface.</span>
<span class="sd">        pme_gridnumber: The number of grid points to include along each</span>
<span class="sd">            lattice edge in PME summation.</span>
<span class="sd">        points: The coordinates (:math:`\mathrm{a.u.}`) where a potential</span>
<span class="sd">            will be interpolated from the PME grid.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The interpolated PME potential at the points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points_project</span> <span class="o">=</span> <span class="n">project_to_grid</span><span class="p">(</span><span class="n">inverse_box</span><span class="p">,</span> <span class="n">pme_gridnumber</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
    <span class="n">interp_potential</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interpn</span><span class="p">(</span>
        <span class="n">grid</span><span class="p">,</span>
        <span class="n">pme_potential</span><span class="p">,</span>
        <span class="n">points_project</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">interp_potential</span>


<span class="k">def</span> <span class="nf">_interp_pme_gradient</span><span class="p">(</span>
        <span class="n">inverse_box</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">grid</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]],</span>
        <span class="n">pme_potential</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">pme_gridnumber</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform the chain rule for the interpolated PME potential gradient.</span>

<span class="sd">    Args:</span>
<span class="sd">        inverse_box: The inverse lattice vectors</span>
<span class="sd">            (:math:`\mathrm{a.u.^{-1}}`) of the box containing the</span>
<span class="sd">            system.</span>
<span class="sd">        grid: Arrays of possible grid indices for interpolation.</span>
<span class="sd">        pme_potential: The PME potential at gridpoints defined in the MM</span>
<span class="sd">            interface.</span>
<span class="sd">        pme_gridnumber: The number of grid points to include along each</span>
<span class="sd">            lattice edge in PME summation.</span>
<span class="sd">        points: The coordinates (:math:`\mathrm{a.u.}`) where a gradient</span>
<span class="sd">            w.r.t. the potential will be interpolated from the PME grid.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The interpolated PME gradient at the points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points_project</span> <span class="o">=</span> <span class="n">project_to_grid</span><span class="p">(</span><span class="n">inverse_box</span><span class="p">,</span> <span class="n">pme_gridnumber</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
    <span class="c1"># This code is largely based on</span>
    <span class="c1"># scipy.interpolate.RegularGridInterpolator._evaluate linear.</span>
    <span class="n">interp_function</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">RegularGridInterpolator</span><span class="p">(</span>
        <span class="n">grid</span><span class="p">,</span>
        <span class="n">pme_potential</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">indices</span><span class="p">,</span> <span class="n">norm_dist</span> <span class="o">=</span> <span class="n">interp_function</span><span class="o">.</span><span class="n">_find_indices</span><span class="p">(</span>
        <span class="n">points_project</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]))</span>
    <span class="n">grad_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),))</span>
    <span class="n">grad_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),))</span>
    <span class="n">grad_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),))</span>
    <span class="k">for</span> <span class="n">edge_indices</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">weight_x</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">weight_y</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">weight_z</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">e_i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">y_i</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">edge_indices</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">norm_dist</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">weight_x</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">weight_z</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">,</span> <span class="n">y_i</span><span class="p">)</span>
                <span class="n">weight_y</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">,</span> <span class="n">y_i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">weight_y</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">weight_x</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">,</span> <span class="n">y_i</span><span class="p">)</span>
                <span class="n">weight_z</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">,</span> <span class="n">y_i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">weight_z</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">weight_y</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">,</span> <span class="n">y_i</span><span class="p">)</span>
                <span class="n">weight_x</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">,</span> <span class="n">y_i</span><span class="p">)</span>
        <span class="n">grad_x</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">interp_function</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">weight_x</span>
        <span class="n">grad_y</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">interp_function</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">weight_y</span>
        <span class="n">grad_z</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">interp_function</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">edge_indices</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">weight_z</span>
    <span class="n">grad_du</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">grad_x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="n">grad_y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="n">grad_z</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="p">),</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">interp_gradient</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">pme_gridnumber</span>
        <span class="o">*</span> <span class="p">(</span><span class="n">grad_du</span> <span class="o">@</span> <span class="n">inverse_box</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">interp_gradient</span>


<div class="viewcode-block" id="project_to_grid">
<a class="viewcode-back" href="../../../../pydft_qmmm.plugins.pme.html#pydft_qmmm.plugins.pme.pme_utils.project_to_grid">[docs]</a>
<span class="k">def</span> <span class="nf">project_to_grid</span><span class="p">(</span>
        <span class="n">inverse_box</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">pme_gridnumber</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Project points into fractional PME grid coordinates.</span>

<span class="sd">    This algorithm is identical to that used in method</span>
<span class="sd">    &#39;pme_update_grid_index_and_fraction&#39; in OpenMM source code,</span>
<span class="sd">    ReferencePME.cpp.</span>

<span class="sd">    Args:</span>
<span class="sd">        inverse_box: The inverse lattice vectors</span>
<span class="sd">            (:math:`\mathrm{a.u.^{-1}}`) of the box containing the</span>
<span class="sd">            system.</span>
<span class="sd">        pme_gridnumber: The number of grid points to include along each</span>
<span class="sd">            lattice edge in PME summation.</span>
<span class="sd">        points: The coordinates (:math:`\mathrm{a.u.}`) which will be</span>
<span class="sd">            projected into the fractional PME grid coordinate space.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The projected points in the fractional grid coordinate space.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fractional_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">inverse_box</span><span class="p">)</span>
    <span class="n">floor_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">fractional_points</span><span class="p">)</span>
    <span class="n">decimal_points</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">fractional_points</span> <span class="o">-</span> <span class="n">floor_points</span><span class="p">)</span> <span class="o">*</span> <span class="n">pme_gridnumber</span>
    <span class="p">)</span>
    <span class="n">integer_points</span> <span class="o">=</span> <span class="n">decimal_points</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">scaled_grid_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span>
        <span class="n">integer_points</span><span class="p">,</span>
        <span class="n">pme_gridnumber</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">decimal_points</span> <span class="o">-</span> <span class="n">integer_points</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scaled_grid_points</span></div>



<span class="nd">@numba</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_compute_reciprocal_exclusions</span><span class="p">(</span>
        <span class="n">external_grid</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">indices</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">positions</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">charges</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">exclusions</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">box</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply exlcusions to relevant PME potential grid points.</span>

<span class="sd">    Args:</span>
<span class="sd">        external_grid: The PME potential at gridpoints.</span>
<span class="sd">        indices: The array indices of PME grid points which will</span>
<span class="sd">            participate in interpolation.</span>
<span class="sd">        positions: The positions (:math:`\mathrm{a.u.}`) of the atoms</span>
<span class="sd">            within subsystems I &amp; II in the principal cell.</span>
<span class="sd">        charges: The partial charges (:math:`e`) of the atoms within</span>
<span class="sd">            subsystems I &amp; II in the principal cell.</span>
<span class="sd">        exclusions: The positions (:math:`\mathrm{a.u.}`) of PME grid</span>
<span class="sd">            points which will participate in interpolation.</span>
<span class="sd">        beta: The Gaussian width parameter in Ewald summation</span>
<span class="sd">            (:math:`\mathrm{a.u.^{-1}}`).</span>
<span class="sd">        box: The lattice vectors (:math:`\mathrm{a.u.}`) of the box</span>
<span class="sd">            containing the system.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The PME potential with contributions from charges in subsystems</span>
<span class="sd">        I &amp; II in the principal cell removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exclusions</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numba</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">ssc</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">exclusions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">box</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="n">ssc</span> <span class="o">+=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="n">ssc</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">erf</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">dr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">erf</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">):</span>
                <span class="n">external_grid</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">beta</span> <span class="o">*</span> \
                    <span class="n">charges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">external_grid</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">charges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">erf</span> <span class="o">/</span> <span class="n">dr</span>
    <span class="k">return</span> <span class="n">external_grid</span>
</pre></div>

          </div>

        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">PyDFT-QMMM</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, John Pederson, Jesse McDaniel.

      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>

    </div>




  </body>
</html>
